PythonAdvanced

function 函数 （要多使用函数，方便，少变量，好改错）

	函数是可以重复执行的语句块，可以重复使用

	作用：
		1、用于封装语句块，提高代码的重用性
		2、定义用户级别的函数

	def 语句 函数定义（创建）语句的语法：
		def 函数名(形参列表):
			语句块

	说明：
		1、函数的名字就是语句块的名称
		2、函数名的命名规则和变量名相同（函数名必须为标识符）
		3、函数有自己的命名空间，在函数外部不可以访问函数内部的变量，在函数内部可以访问函数外部的变量，通常让函数处理外部数据需要用参数给函数传入一些数据。
		4、函数的参数列表可以为空
		5、语句部分不能为空。如果为空需要补充pass语句

	示例：001fun.py

函数的调用

    函数名（实际调用传递参数列表）
    注：实际调用传递参数以后称为实参

    说明：
        函数调用是一个表达式
        如果没有return语句，次函数执行完毕后返回None对象，如果函数需要返回其他的对象需要用到return语句

    示例：001def.py

return 语句
	
	语法：return [表达式] []可以省略

	作用：用于函数中，结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系

	说明：
		1、return语句后跟的表达式可以省略，省略后相当于return None
		2、如果函数没有return语句，则函数执行完最后一条语句后返回None（相当于在最后加了一条return None语句）
		3、函数调用一定会返回一个对象的引用

参数传递

	传递方式：（位置传参、关键字传参）

	位置传参：实际参数（实参）的对应关系与形式参数（形参）的对应关系是按位置来依次对应的

		示例：
			def myfun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			myfun(1, 2, 3)

		说明：实际参数和形式参数通过位置进行传递的匹配，实参个数必须与形参个数相同

	序列传参：序列传参是指在函数调用过程中，用 * 将序列拆解后按位置传参的方式进行参数传递

		示例：
			def myfun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			s1 = [1, 2, 3]
			myfun(*s1)         # 等同于myfun(s[0], s[1], s[2])
			s2 = "ABC"
			myfun(*s2)

	关键字传参：关键字传参是指传参时，按着形参的名称给形参赋值，实参和形参按名称进行匹配

		示例：
			def my fun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			myfun(b=22, c=33, a=11) # 等同于myfun(11,22,33)
			myfun(c=3, b=2, a=1)

		说明：实参和形参可以不按照位置匹配

	字典关键字传参：是指实参为字典，将字典用 ** 拆解后进行关键词传参

		示例：
			def my fun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			d = {'c': 33, 'b': 22, 'a': 11}
			myfun(**d) # 拆解字典后再传参

		说明：字典的键名和形参名必须一致；字典键名必须为字符串；字典的键名要在形参中存在

	<综合传参>:函数传递方式，在能确定形参能唯一匹配到相应实参的情况下可以任意组合

		示例：
			def mufun(a, b, c):
				pass
			myfun(100, *[200, 300])
			mufun(*'AB', 300)
			myfun(1, **{'c': 3, 'b': 2})
			myfun(b=2, c=3, 1)  # 错误，不能确定1给谁

		说明：传参时先位置传参，后关键字传参

形参（如何接收实参）

	<缺省参数>

		语法：def 函数名(形参名1=默认实参1, 形参名2=默认实参2....)

		示例：
			def info(name, age=1, address='未填写'):
				print(name, "今年", age, "岁，家庭地址是：", adress)
			info('Howie', 15)
			info('Howie', 20, '背景')
			info('小李')

		说明：
			1、缺省参数必须从右到左依次存在，如果一个参数有缺省参数，则基右侧的所有参数都必须有缺省参数，如：
				def test(a, b=10, c): # 错的
					pass
			2、缺省参数可以有0个或多个，甚至全部都有缺省参数

	函数的形参定义方式：顺序（位置形参，星号元组形参，命名关键字形参，双星号字典形参）

	<位置形参>

		语法：def 函数名(形参名1, 形参名2, ....)
				语句块

	<星号元组形参>

		语法：def 函数名(*元组形参名):
				语句块

		说明：元组形参名通常用'args'（绑定的是一个元组）

		示例:
			def func(*args):
				print("参数个数是", len(args))
				print("args =", args)
			func(1,2,3,4)
			func("hello","world",1,2,3)

	<命名关键字形参>

		语法：def 函数名(*, 命名关键字形参)：
				语句
			或
			  def 函数名(*args, 命名关键字形参)：
			  	语句

		作用：所有的参数都必须用关键字传参或字典关键字传参传递

		示例：
			def fn(*, d, e):
				print("d=", d)
				print("e=", e)
			fn(d=100, e=200)
			fn(1, 2) # 错误，因为有*号，只要有*，右边强制进行关键字传参

			def fn(*args, d, e):
				print(args)
				print("d=", d)
				print("e=", e)
			fn(1, 2, d=100, e=200)
			例如：print内部函数

	<双星号字典形参>

		语法：def 函数名(**字典形参名)：
				语句

		作用：收集多个的关键字形参
		说明：通常字典形参名定为:"kwargs"

		示例：
			def func(**kwargs):
				print("关键字参数的个数是：", len(fnkwargs))
				print("kwargs =", kwargs)
			func(name='Howie', age = 15)

	【函数参数自左向右的顺序为：位置形参，星号元组形参，命名关键字形参，双星号字典形参】
		综合示例：
			def f1(a, b, *args, c, **kwargs):
				print("a=", a)
				print("b=", b)
				print("args=", args)
				print("c=", c)
				print("kwargs=", kwargs)
			f1(1, 2, 3, 4, d=6, c=5, e=7)
			f1(*"hello", d=6, **{'c':5, 'e':7})

不定长参数
	
	def fn(*args, **kwargs):
		print(args)
		print(kwargs)
	# 可以接受任意的位置传参和关键字传参

全局变量和局部变量

	局部变量：定义在函数内部的变量称为局部变量（函数的形参也是局部变量）
			 局部变量只能在函数内部使用
			 局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁

	说明：
		1、在函数内首次对变量赋值是创建局部变量，在此为变量赋值是修改局部变量的绑定关系
		2、在函数内部的赋值语句不会对全局变量造成影响
		3、局部变量只能在其被声明的函数内部访问，而全局变量可以在整个模块范围内访问

	全局变量：定义在函数外部，模块内部的变量称为全局变量
			 所有的函数都可以直接发访问（但函数内部不能将其赋值）

	示例
		a = 100
		b = 200
		def fx(c):
			d = 400
			print(a,b,c,d)
		fx(300)
		print('a=', a)

globals locals 函数
	
	globals() 返回当前全局作用域内变量的字典
	locals() 返回当前作用域内变量的字典

	示例
		a = 1
		b = 2
		c = 3
		def f1(c, d):
			e = 300
			print("locals()返回:", locals())
			print("globals()返回:", globals())
			print(globals()['c'])
		f1(100,200)

函数变量
	
	函数名是变量，他在创建函数时绑定一个函数

	示例
		def f1():
			print("f1被调用")
		fx = f1
		fx() # 等同于f1

	示例2
		def f1():
			print("hello")
		def f2():
			print("world")
		f1, f2 = f2, f1
		f1()

	一个函数可以作为另一个函数的参数传递

		示例
			def f1():
				print("hello")
			def f2():
				print("world")	

			def fx(fn):
				print(fn)
				fn()
			fx(f1)
			fx(f2)

		示例
			def fx(a, fn):
				return fn(a)
			L = [5,9,4,6]
			print('最大值是:', fx(L, max))

	函数可以返回另一个函数（即：另一个函数可以返回一个函数）

		示例
			def get_fx():
				s = input('请输入您要的操作')
				if s == '求最大':
					return max
				elif s == '求最小':
					return min
				elif s == '求和':
					return sum
			L = [2,3,6,8,10]
			print(L)
			f1 = get_fx()
			print(f1(L))

函数的嵌套定义

	函数的嵌套定义是指一个函数里的def语句来创建其他函数

	示例
		def fn_outer():
			print("fn_outer被调用！")

			def fn_inner():
				print("fn_inner被调用~")

			fn_inner()
			fn_inner()

			print("fn_outer被调用！")

			return fn_inner

		fn_outer()
		fx = fn_outer()
		fx()

python 作用域

	作用于也叫名字空间，是访问变量时，查找变量名的范围空间，如果上一层没有的话，会一层一层向外找，无法修改内建作用域的变量

	python的四个作用域 LEGB L --> E --> G --> B

		局部作用域			Local Function
		外部嵌套函数作用域	Enclosing Function Locals
		函数定义所在模块（文件）的作用域	Global（module）
		python 内置模块的作用域			Builtin（python） 

	v = 100	# 全局作用域
	def fun1():
		v = 200	# 外部嵌套函数作用域
		print('fun1内的v=', v)

		def fun2():
			v = 300	# 局部作用域
			print("fun2内的v=", v)
		fun2()
	fun1()
	print("v=",v)

global 语句

	作用：
		1、告诉解释器，global语句声明的一个或多个变量，这些变量的作用域为模块级的作用域，也称作全局变量
		2、全局声明（global）将赋值变量映射到模块文件内部的作用域

	语法：global 变量1, 变量2, ...

	说明：
		1、全局变量如果要在函数内部被赋值，则必须经过全局声明（否则会被认为是局部变量）
		2、全局变量在函数内部不经过声明就可以直接访问
		3、不能先声明局部的变量，再用global声明为局部变量，此做法不符合规则
		4、global变量列表里的变量不能出现在次作用于的形参列表里

	示例
		v = 100
		def f():
			global v
			v = 200
		f()
		print(v)

nonlocal 语句
	
	作用：告诉解释器，nonlocal声明的变量不是局部变量，也不是全局变量，而是外部嵌套函数内的变量

	语法：nonlocal 变量名1, 变量名2, ...

	说明：
		1、nonlocal语句只能在被嵌套函数内部进行使用
		2、访问nonlocal变量将对外部嵌套函数的作用域的变量进行操作
		3、当有两层或两层以上的函数嵌套时，访问nonlocal变量只对最近一层的变量进行操作
		4、nonlocal语句的变量列表里的变量名，不能出现在次函数的参数列表中

	示例
		var = 100

		def f1():
			var = 200
			print("f1里的var=", var)

			def f2():
				nonlocal var = 300
				print("f2里的var=", var)

			f2()
			print("f2调用结束后var值为",var)

		f1()
		print("全局的var=", var)

lambda 表达式（又称匿名函数）
	
	作用：
		创建一个匿名函数对象，同def类似，但不提供函数名

	语法：lambda [参数1, 参数2, ...]: 表达式   （[]里可以省略）

	说明：
		1、lambda只是一个表达式，他用来创建一个对象
		2、当lambda表达式调用时，先执行冒号后（：）
		3、lambda表达式创建的函数只能包含一条“表达式”
		4、lambda比函数简单且可以随时创建和销毁，有利于减少程序的偶合度

	示例
		def myadd(x, y):
			return x+y
		# 可以改写为：
		myadd = lambda x, y: x + y
		print('2 + 3 =', myadd(x, y))

		def fx(f, x, y):
			print(f(x, y))
		fx((lambda a, b: a + b), 100, 200)
		fx((lambda a, b: a * b), 100, 200)	

eval() exec() 函数

	eval()
		格式：eval(source, global=None, locals=None)
		作用：摆一个字符串当成一个表达式来执行，返回表达式执行后的结果
		示例：
			x = 100
			y = 200
			a = eval('x + y')
			print(a)

	exec()
		格式：exec(source, globals=None, locals=None)
		作用：把一个字符串当成程序来执行
		示例：
			x = 100
			y = 200
			s = 'z = x+y; print(z); del z; print("删除成功")'
			exec(s)

	参数globals和locals
		这两个参数是用来设置'表达式'或'程序'运行的全局变量和局部变量

		示例：
			x = 100
			y = 200
			s = 'print(x, y, x+y)'
			exec(s)
			exec(s, {'x':10, 'y':20}) # 10, 20, 30
			exec(s, {'x':10}, {'x':1, 'y':2}) # 1 2 3
			exec(s, {'x':10}, {'y':2}) # 10 2 12

函数式编程
	
	函数式编程是指用一系列函数决定问题
	函数是一等公民，函数本身可以赋值给变量，复制后绑定函数，允许将行数本身作为参数传入另一个函数，允许返回一个函数

	函数的可重入性:
		可重入是指一个函数传递的参数一定，则结果必须一定
		要求：def定义的函数不要访问除局部变量以外的变量

		不可重入：
			y = 200
			def myadd(x):
				return x+y
			print(myadd(10))

		可重入：
			def myadd(x, y):
				return x + y
			print(myadd(10,20))

高阶函数 High Order Function
	满足下列条件中的一个函数即为高阶函数
		1、函数接受一个或多个函数作为参数传入
		2、函数返回一个函数

python中内建（builtins）的高阶函数

map() 函数
	man(func, *interables) 用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象，当最短的一个可迭代对象不再提供数据时，次迭代对象生成结束

	示例
		def pow2(x):
			return x ** 2
		for x in map(pow2, range(1, 10)):
			print(x)

		# 内建的pow(x, y, z=None) # z 是对z求余
		# 生成 1 ** 4, 2 ** 3, 3 ** 2, 4 ** 1 
		for x in map(pow, range(1, 10), range(4, 0, -1)):
			print(x)

		for x in map(pow,[2,3,5,7],[4,3,2,1],range(5,10)):
			print(x)

		def pow2(x):
			return x ** 2
		print(sum(map(pow2, range(1,10))))

		print(sum(map(lambda x: x**2, range(1, 10))))
		print(sum(map(pow, range(1,10), range(9,0,-1))))

filter 函数
	格式：filter(fun, interable)
	作用：筛选可迭代对象iterable中的数据，返回一个可迭代对象，此可迭代对象将对iterable进行筛选
	说明：函数func将对每个元素进行求值，返回False则将此数据丢弃，True则保留此数据

	示例
		def isodd(x):
			return x % 2 == 1
		for x in filter(isodd, range(10)):
			print(x)
		even = [x for x in filter(lambda x: x % 2 == 0, range(10))]	
		even = list(filter(lambda x: x % 2 == 0, range(10)))

sorted 函数
	作用：将原可迭代对象的数据进行排序，生成排序后的列表
	格式：sorted(iterable, key=None, reverse=False)
	说明：iterable是尅迭代对象、key函数是用来提供一个参考值，这个值作为排序的依据、reverse标志用来设置升序还是降序
	示例
		L = [5, -2, -4, 0, 3, 1]
		L2 = sorted(L) 
		L2 = sorted(L, reverse=True) 
		L3 = sorted(L, key=abs)

		name = ['Tom', 'Jerry', 'Spike', 'Tyke']
		sorted(name, key=len)
		# 让names排序，排序的依据是字符串的反序
		# 'moT' 'yrreJ'.........
		def fx(name):
			return name[::-1]

		L2 = sorted(name, key=fx)
		L3 = sorted(name, key=lambda n: n[::-1])
		print(L2)


recursion 递归函数

	函数直接或间接地调用自身

	说明：
	1、递归一定要控制递归的层数，当符合某一条件时要终止递归
	2、几乎所有的递归都能用while循环来代替。

	控制递归层数的示例：
		def fx(n):
			print("递归进入第", n, "层")
			if n == 3:
				return
			fx(n + 1)
			print("递归退出", n, "层")
		fx(1)
		print("程序结束")

	优点：递归可以把问题简单化，让思路更为清晰，代码简洁
	缺点：递归因系统环境影响大，当递归深度太大时，可能会得到不可预知的后果

	递归函数的实现方法：
		先假设函数已经实现

		# 03_recursion_sum.py 1+2+....100
		def mysum(x):
			if x == 1:
				return 1
			return x + mysum(x-1)
		v = mysum(100)
		print(v)

closure 闭包

	将内嵌函数的语句和这些语句的执行环境打印在一起时，得到的对象称为闭包（closure）

	三个条件：
		1、必须有一个内嵌函数
		2、内嵌函数必须引用外部函数中的变量
		3、外部函数返回值必须是内嵌函数

	示例：
		def make_power(y):
			def fx(arg):
				return arg ** y
			return fx

		pow2 = make_power(2) # y 绑定2，留在了make_power环境里，传给了里面的fx中的y
		pow3 = make_power(3)
		print('3的平方是：', pow2(3)) # 9
		print('3的平方是：', pow3(3)) # 27

	数学函数示例：
		# 函数 y = a*x**2 + b*x + c
		def make_function(a, b, c):
			def fx(x):
				return a*x**2 + b*x + c
			return fx
		fx1 = make_function(4, 5, 6) # 创建一个 y = 4*2 + 5*x + 6的函数用fx1绑定
		print(fx1(2))

decorators 装饰器 (闭包概念)

	函数装饰器：是指装饰的是一个函数，传入的是一个函数，返回的也是一个函数

	语法：
		def 装饰器函数名(参数)：
			语句块
			return 函数对象

	被装饰函数的语法：
		@装饰器函数名
		def 函数名(形参列表):
			语句块

	示例：
		#定义一个装饰器函数
		def mydeco(fn):
			def fx():
				print('++++++++++')
				fn()
				print('----------')
			return fx

		@mydeco   #   相当于myfunc = mydeco(myfunc)
		def myfunc():
			print("myfunc被调用")

		myfunc()

	案例：023deco.py

函数的文档字符串

	函数内部，第一个没有赋值给任何变量的字符串为函数文档字符串

	语法：
		def 函数名(形参列表):
			'''函数的文档字符串'''
			函数语句块

	示例：
		def cba():
			'''这是一块文档字符串'''
			pass
		help(cba)

函数的属性 __doc__ __name__

	__doc__ 属性用于绑定该函数的文档字符串

	示例：
		def fx(a, b):
			'''
			这是函数的文档文档字符串
			这是第二行...
			'''
		print(fx.__doc__)

		def fx():
			pass
		f1 = fx
		print(f1.__name__)

函数定义语句（def语句的语法）

	[@装饰器名1]
	[@装饰器名2]
	...
	def 函数名([位置形参], [*[元组形参名]], [命名关键字形参], [**字典形参])
		'''文档字符串'''
		语句块
	注：[]内的可以省略


面试题

	L = [1, 2, 3]
	def f(n, lst=[]):
		lst.append(n)
		print(lst)
	# 按顺序往下操作，请问结果是什么
	f(4, L) # [1,2,3,4]
	f(5, L) # [1,2,3,4,5]
	f(100)  # [100]
	f(200)  # [100, 200]

    # 默认参数（缺省参数）绑定在函数对象内部，随着函数的生命一直存在
    # lst=[]是缺省参数，lst一旦调用，一直存在于f函数中

    解决方法：
    def f(n, lst=None):
    	if lst = None:
    		lst = []
		lst.append(n)
		print(lst)

Moudule 模块

	模块是一个包含有一系列数据、函数、类等组成的程序组
	模块是一个文件，模块名通常以.py结尾

	作用：
		让一些相关的数据，函数，类等有逻辑地组织在一起，使逻辑结构更加清晰
		模块中的数据，函数的类等可提供其他模块或程序使用

	分类：
		1、内置模块（builtins），在解释器的内部可以直接使用
		2、标准库模块，安装python时已安装且可以直接使用
		3、第三方模块（通常为开源），需要自己安装
		4、用户自己的模块（可以作为其他人的第三方模块）

import 模块的导入语句

	语法：import 模块名1[as 模块新名1][,模块名2 as 模块新名2], ...

	示例：
		# 导入数学模块
		import math
		# 导入系统模块sys和os模块
		import sys, os

	作用：将某模块整体导入到当前模块
	用法：模块.属性名

	dir(obj) 函数返回模块所有属性的字符串列表
	help(obj) 可以查看模块相关的文档字符串

from import 语句

	语法：from 模块名 import 模块属性名1 [as 属性新名1] [, 模块属性名2[as 属性新名2]]
	作用：将某模块内的一个或多个属性导入到当前模块的作用域

	示例：
		from math import pi
		from math import pow, sqrt
		from math import factorial as fac
		fac(5)
		sqrt(9)

from import *语句

	将某模块的所有属性全部导入到当前模块,但是会和变量名字冲突

	示例：
		from math import *
		print(sin(10))
		sqrt(9)

dir 函数
	dir([对象]) 返回一个字符串列表
	作用：
		1、如果没有参数调用，则返回当前作用域内的所有变量的列表
		2、如果给定一个对象作为参数，则返回这个对象的所有变量

模块们

	math数学模块
	time时间模块
		公元纪年
		计算机元年从1970.1.1零时，每过一秒+1
		UTC时间（Coordinated Universal Time）是从Greenwich时间开始计算的。UTC时间不会因失去问题而产生错误
		DST阳关节约时间（Daylight Saving Time）又称夏令时
		
		time.time() 返回计算机元年到现在过了多少秒
		time.sleep(secs) 让程序按给指定秒数的浮点数睡眠一段时间
		time.gmtime() 用给指定秒数转换为UTC表达的时间元组，缺省式返回当前UTC时间元组
		time.asctime([tuple]) 将时间元祖转换为日期时间字符串
		time.mktime(tuple) 将本地日期时间元组转换为新纪元秒数时间
			time.mktime((2018, 1, 1, 12, 20, 30, 0, 0, 0))
		time.localtime
			time.localtime()









