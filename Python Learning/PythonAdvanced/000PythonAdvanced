PythonAdvanced

function 函数 （要多使用函数，方便，少变量，好改错）

	函数是可以重复执行的语句块，可以重复使用

	作用：
		1、用于封装语句块，提高代码的重用性
		2、定义用户级别的函数

	def 语句 函数定义（创建）语句的语法：
		def 函数名(形参列表):
			语句块

	说明：
		1、函数的名字就是语句块的名称
		2、函数名的命名规则和变量名相同（函数名必须为标识符）
		3、函数有自己的命名空间，在函数外部不可以访问函数内部的变量，在函数内部可以访问函数外部的变量，通常让函数处理外部数据需要用参数给函数传入一些数据。
		4、函数的参数列表可以为空
		5、语句部分不能为空。如果为空需要补充pass语句

	示例：001fun.py

函数的调用

    函数名（实际调用传递参数列表）
    注：实际调用传递参数以后称为实参

    说明：
        函数调用是一个表达式
        如果没有return语句，次函数执行完毕后返回None对象，如果函数需要返回其他的对象需要用到return语句

    示例：001def.py

return 语句
	
	语法：return [表达式] []可以省略

	作用：用于函数中，结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系

	说明：
		1、return语句后跟的表达式可以省略，省略后相当于return None
		2、如果函数没有return语句，则函数执行完最后一条语句后返回None（相当于在最后加了一条return None语句）
		3、函数调用一定会返回一个对象的引用

参数传递

	传递方式：（位置传参、关键字传参）

	位置传参：实际参数（实参）的对应关系与形式参数（形参）的对应关系是按位置来依次对应的

		示例：
			def myfun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			myfun(1, 2, 3)

		说明：实际参数和形式参数通过位置进行传递的匹配，实参个数必须与形参个数相同

	序列传参：序列传参是指在函数调用过程中，用 * 将序列拆解后按位置传参的方式进行参数传递

		示例：
			def myfun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			s1 = [1, 2, 3]
			myfun(*s1)         # 等同于myfun(s[0], s[1], s[2])
			s2 = "ABC"
			myfun(*s2)

	关键字传参：关键字传参是指传参时，按着形参的名称给形参赋值，实参和形参按名称进行匹配

		示例：
			def my fun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			myfun(b=22, c=33, a=11) # 等同于myfun(11,22,33)
			myfun(c=3, b=2, a=1)

		说明：实参和形参可以不按照位置匹配

	字典关键字传参：是指实参为字典，将字典用 ** 拆解后进行关键词传参

		示例：
			def my fun(a, b, c):
				print('a绑定的是',a)
				print('b绑定的是',b)
				print('c绑定的是',c)
			d = {'c': 33, 'b': 22, 'a': 11}
			myfun(**d) # 拆解字典后再传参

		说明：字典的键名和形参名必须一致；字典键名必须为字符串；字典的键名要在形参中存在

	<综合传参>:函数传递方式，在能确定形参能唯一匹配到相应实参的情况下可以任意组合

		示例：
			def mufun(a, b, c):
				pass
			myfun(100, *[200, 300])
			mufun(*'AB', 300)
			myfun(1, **{'c': 3, 'b': 2})
			myfun(b=2, c=3, 1)  # 错误，不能确定1给谁

		说明：传参时先位置传参，后关键字传参

形参（如何接收实参）

	<缺省参数>

		语法：def 函数名(形参名1=默认实参1, 形参名2=默认实参2....)

		示例：
			def info(name, age=1, address='未填写'):
				print(name, "今年", age, "岁，家庭地址是：", adress)
			info('Howie', 15)
			info('Howie', 20, '背景')
			info('小李')

		说明：
			1、缺省参数必须从右到左依次存在，如果一个参数有缺省参数，则基右侧的所有参数都必须有缺省参数，如：
				def test(a, b=10, c): # 错的
					pass
			2、缺省参数可以有0个或多个，甚至全部都有缺省参数

	函数的形参定义方式：顺序（位置形参，星号元组形参，命名关键字形参，双星号字典形参）

	<位置形参>

		语法：def 函数名(形参名1, 形参名2, ....)
				语句块

	<星号元组形参>

		语法：def 函数名(*元组形参名):
				语句块

		说明：元组形参名通常用'args'（绑定的是一个元组）

		示例:
			def func(*args):
				print("参数个数是", len(args))
				print("args =", args)
			func(1,2,3,4)
			func("hello","world",1,2,3)

	<命名关键字形参>

		语法：def 函数名(*, 命名关键字形参)：
				语句
			或
			  def 函数名(*args, 命名关键字形参)：
			  	语句

		作用：所有的参数都必须用关键字传参或字典关键字传参传递

		示例：
			def fn(*, d, e):
				print("d=", d)
				print("e=", e)
			fn(d=100, e=200)
			fn(1, 2) # 错误，因为有*号，只要有*，右边强制进行关键字传参

			def fn(*args, d, e):
				print(args)
				print("d=", d)
				print("e=", e)
			fn(1, 2, d=100, e=200)
			例如：print内部函数

	<双星号字典形参>

		语法：def 函数名(**字典形参名)：
				语句

		作用：收集多个的关键字形参
		说明：通常字典形参名定为:"kwargs"

		示例：
			def func(**kwargs):
				print("关键字参数的个数是：", len(fnkwargs))
				print("kwargs =", kwargs)
			func(name='Howie', age = 15)

	【函数参数自左向右的顺序为：位置形参，星号元组形参，命名关键字形参，双星号字典形参】
		综合示例：
			def f1(a, b, *args, c, **kwargs):
				print("a=", a)
				print("b=", b)
				print("args=", args)
				print("c=", c)
				print("kwargs=", kwargs)
			f1(1, 2, 3, 4, d=6, c=5, e=7)
			f1(*"hello", d=6, **{'c':5, 'e':7})

不定长参数
	
	def fn(*args, **kwargs):
		print(args)
		print(kwargs)
	# 可以接受任意的位置传参和关键字传参

全局变量和局部变量

	局部变量：定义在函数内部的变量称为局部变量（函数的形参也是局部变量）
			 局部变量只能在函数内部使用
			 局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁

	说明：
		1、在函数内首次对变量赋值是创建局部变量，在此为变量赋值是修改局部变量的绑定关系
		2、在函数内部的赋值语句不会对全局变量造成影响
		3、局部变量只能在其被声明的函数内部访问，而全局变量可以在整个模块范围内访问

	全局变量：定义在函数外部，模块内部的变量称为全局变量
			 所有的函数都可以直接发访问（但函数内部不能将其赋值）

	示例
		a = 100
		b = 200
		def fx(c):
			d = 400
			print(a,b,c,d)
		fx(300)
		print('a=', a)

globals locals 函数
	
	globals() 返回当前全局作用域内变量的字典
	locals() 返回当前作用域内变量的字典

	示例
		a = 1
		b = 2
		c = 3
		def f1(c, d):
			e = 300
			print("locals()返回:", locals())
			print("globals()返回:", globals())
			print(globals()['c'])
		f1(100,200)

函数变量
	
	函数名是变量，他在创建函数时绑定一个函数

	示例
		def f1():
			print("f1被调用")
		fx = f1
		fx() # 等同于f1

	示例2
		def f1():
			print("hello")
		def f2():
			print("world")
		f1, f2 = f2, f1
		f1()

	一个函数可以作为另一个函数的参数传递

		示例
			def f1():
				print("hello")
			def f2():
				print("world")	

			def fx(fn):
				print(fn)
				fn()
			fx(f1)
			fx(f2)

		示例
			def fx(a, fn):
				return fn(a)
			L = [5,9,4,6]
			print('最大值是:', fx(L, max))

	函数可以返回另一个函数（即：另一个函数可以返回一个函数）

		示例
			def get_fx():
				s = input('请输入您要的操作')
				if s == '求最大':
					return max
				elif s == '求最小':
					return min
				elif s == '求和':
					return sum
			L = [2,3,6,8,10]
			print(L)
			f1 = get_fx()
			print(f1(L))

函数的嵌套定义

	函数的嵌套定义是指一个函数里的def语句来创建其他函数

	示例
		def fn_outer():
			print("fn_outer被调用！")

			def fn_inner():
				print("fn_inner被调用~")

			fn_inner()
			fn_inner()

			print("fn_outer被调用！")

			return fn_inner

		fn_outer()
		fx = fn_outer()
		fx()

python 作用域

	作用于也叫名字空间，是访问变量时，查找变量名的范围空间，如果上一层没有的话，会一层一层向外找，无法修改内建作用域的变量

	python的四个作用域 LEGB L --> E --> G --> B

		局部作用域			Local Function
		外部嵌套函数作用域	Enclosing Function Locals
		函数定义所在模块（文件）的作用域	Global（module）
		python 内置模块的作用域			Builtin（python） 

	v = 100	# 全局作用域
	def fun1():
		v = 200	# 外部嵌套函数作用域
		print('fun1内的v=', v)

		def fun2():
			v = 300	# 局部作用域
			print("fun2内的v=", v)
		fun2()
	fun1()
	print("v=",v)

global 语句

	作用：
		1、告诉解释器，global语句声明的一个或多个变量，这些变量的作用域为模块级的作用域，也称作全局变量
		2、全局声明（global）将赋值变量映射到模块文件内部的作用域

	语法：global 变量1, 变量2, ...

	说明：
		1、全局变量如果要在函数内部被赋值，则必须经过全局声明（否则会被认为是局部变量）
		2、全局变量在函数内部不经过声明就可以直接访问
		3、不能先声明局部的变量，再用global声明为局部变量，此做法不符合规则
		4、global变量列表里的变量不能出现在次作用于的形参列表里

	示例
		v = 100
		def f():
			global v
			v = 200
		f()
		print(v)

nonlocal 语句
	
	作用：告诉解释器，nonlocal声明的变量不是局部变量，也不是全局变量，而是外部嵌套函数内的变量

	语法：nonlocal 变量名1, 变量名2, ...

	说明：
		1、nonlocal语句只能在被嵌套函数内部进行使用
		2、访问nonlocal变量将对外部嵌套函数的作用域的变量进行操作
		3、当有两层或两层以上的函数嵌套时，访问nonlocal变量只对最近一层的变量进行操作
		4、nonlocal语句的变量列表里的变量名，不能出现在次函数的参数列表中

	示例
		var = 100

		def f1():
			var = 200
			print("f1里的var=", var)

			def f2():
				nonlocal var = 300
				print("f2里的var=", var)

			f2()
			print("f2调用结束后var值为",var)

		f1()
		print("全局的var=", var)

lambda 表达式（又称匿名函数）
	
	作用：
		创建一个匿名函数对象，同def类似，但不提供函数名

	语法：lambda [参数1, 参数2, ...]: 表达式   （[]里可以省略）

	说明：
		1、lambda只是一个表达式，他用来创建一个对象
		2、当lambda表达式调用时，先执行冒号后（：）
		3、lambda表达式创建的函数只能包含一条“表达式”
		4、lambda比函数简单且可以随时创建和销毁，有利于减少程序的偶合度

	示例
		def myadd(x, y):
			return x+y
		# 可以改写为：
		myadd = lambda x, y: x + y
		print('2 + 3 =', myadd(x, y))

		def fx(f, x, y):
			print(f(x, y))
		fx((lambda a, b: a + b), 100, 200)
		fx((lambda a, b: a * b), 100, 200)	

eval() exec() 函数

	eval()
		格式：eval(source, global=None, locals=None)
		作用：摆一个字符串当成一个表达式来执行，返回表达式执行后的结果
		示例：
			x = 100
			y = 200
			a = eval('x + y')
			print(a)

	exec()
		格式：exec(source, globals=None, locals=None)
		作用：把一个字符串当成程序来执行
		示例：
			x = 100
			y = 200
			s = 'z = x+y; print(z); del z; print("删除成功")'
			exec(s)

	参数globals和locals
		这两个参数是用来设置'表达式'或'程序'运行的全局变量和局部变量

		示例：
			x = 100
			y = 200
			s = 'print(x, y, x+y)'
			exec(s)
			exec(s, {'x':10, 'y':20}) # 10, 20, 30
			exec(s, {'x':10}, {'x':1, 'y':2}) # 1 2 3
			exec(s, {'x':10}, {'y':2}) # 10 2 12